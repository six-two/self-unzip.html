<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Create Page</title>
</head>
<body>
    
<script src="ascii85.js"></script>
<script src="fflate.js"></script>

<script>
    const get_javascript_code = (page_type, file_name) => {
        const decode_UTF8 = "const og_text=new TextDecoder().decode(og_data)";
        if (page_type == "eval") {
            return decode_UTF8 + ';console.debug(`Evaluating code:\n${og_text}`);eval(og_text)';
        } else if (page_type == "replace") {
            return decode_UTF8 + ';window.onload=()=>{let n=document.open("text/html","replace");n.write(og_text);n.close()}';
        } else if (page_type == "download") {
            return 'let b=new Blob([og_data],{type:"application/octet-stream"});let u=URL.createObjectURL(b);'
                    + 'document.body.innerHTML=`<h1>Unpacked ' + file_name + '</h1><a href="${u}" download="' +
                    file_name + '">Click here to download</a>`';
        } else {
            console.error("Unknown page type:", page_type);
        }
    }


    let template;
    fetch("template.html").then(r => r.text()).then(text => {
        console.log(`Received template file (${text.length} bytes)`);
        console.debug(text);
        template = text;
    });

    const replace_placeholder = (template, placeholder, contents) => {
        // For some reason the normal string replace function fucks up on some pages.
        // Plus this ensures, that the template has exactly one occurence of the placeholder.
        const parts = template.split(placeholder);
        if (parts.length == 2) {
            return `${parts[0]}${contents}${parts[1]}`;
        } else {
            console.error(`Template contains ${parts.length - 1} instances of placeholder "${placeholder}", but expected exactly 1: "${template}"`);
            return template;
        }
    };

    const encode_data = (text) => {
        // first convert the string into a byte array
        // let enc = fflate.strToU8(text);
        let enc = text;// if the input is bytes

        // then ZIP the byte array
        enc = fflate.compressSync(enc);

        // then encode the result using ASCII85
        enc = ascii85.fromByteArray(enc);

        // make the value a safe javascript string (assuming douple quotes are used)
        enc = enc.replaceAll('"', "v");
        enc = enc.replaceAll("\\", "w");
        enc = enc.replaceAll("\n", "").replaceAll("\r", "");
        return enc;
    }

    const set_download_data = (name, mime_type, data) => {
        const fileBlob = new Blob([data], {type: mime_type});

        const link = document.getElementById("download");
        link.setAttribute("href", URL.createObjectURL(fileBlob));
        link.setAttribute("download", name);
    }

    const create_page = (text, file_name, page_type) => {
        document.getElementById("og_size").innerText = `${text.length} bytes`;

        const c_data = encode_data(text);
        document.getElementById("enc_size").innerText = `${c_data.length} bytes`;

        const code = get_javascript_code(page_type, file_name)

        let page = template;
        page = replace_placeholder(page, "{{CODE}}", code);
        page = replace_placeholder(page, "{{DATA}}", c_data);

        console.log("Generated page");
        console.debug(page);
        document.getElementById("page_size").innerText = `${page.length} bytes`;

        set_download_data("self_extract.html", "text/html", page);
    }

    const reset = () => {
        for (id in ["og_size", "enc_size", "page_size"]) {
            document.getElementById("enc_size").innerText = "N/A";
        }
    };
    
    let global_file_name, global_file_contents, global_page_type;
    window.addEventListener("load", () => {
        const input = document.getElementById("file");
        input.addEventListener("change", () => { 
            const r = new FileReader();
            r.onload = () => {
                global_file_contents = new Uint8Array(r.result);
                rebuild_page();
            }
            global_file_name = input.files[0].name;
            global_file_contents = null;
            for (id in ["og_size", "enc_size", "page_size"]) {
                document.getElementById("enc_size").innerText = "N/A";
            }
            r.readAsArrayBuffer(input.files[0]);
            reset();
        });

        const page_type_selector = document.getElementById("page_type");
        global_page_type = page_type_selector.value;
        page_type_selector.addEventListener("change", () => {
            global_page_type = page_type_selector.value;
            rebuild_page();
        });
    });

    const rebuild_page = () => {
        reset();
        if (!global_file_name || !global_file_contents) {
            alert("Please upload a file first");
        } else {
            create_page(global_file_contents, global_file_name, global_page_type);
        }
    }
</script>

    <h1>Self Extracting Page Creator</h1>
    <p>This web application allows you to create a self extracting web page.
    Example usecases include...
    <ul>
        <li>... compressing a really big web page, so that it takes up less bandwith / storage.</li>
        <li>... obfuscating potentially dangerous files, so that they do not immediately get flagged by security software.</li>
        <li>... obfuscating data, so that it can not be found by using automated search tools like grep.</li>
    </ul>
</p>

    <h2>Input</h2>
    <input type="file" id="file">

    <p>
        <label for="page_type">What should be done, when the content is decrypted?</label>

        <select id="page_type">
        <option value="eval">Execute contents as JavaScript</option>
        <option value="replace" selected>Show contents as HTML page</option>
        <option value="download">Download contents as a file</option>
        </select>
    </p>

    <h2>Stats</h2>
    <p>Original size: <span id="og_size">N/A</span></p>
    <p>Encoded size: <span id="enc_size">N/A</span></p>
    <p>Complete page size: <span id="page_size">N/A</span></p>


    <h2>Result</h2>
    Click here to download the <a id="download">self extracting page</a>
</body>
</html>
